double getSpeedRotateToPoint(double robot_x, double robot_y, double point_x, double point_y, double angleOrigin2Robot){
    long double vectorRobot2BallX = (point_x - robot_x);
    long double vectorRobot2BallY = (point_y - robot_y);
    long double modVectorRobot2Ball = sqrt(pow(vectorRobot2BallX, 2) + pow(vectorRobot2BallY, 2));

    vectorRobot2BallX = vectorRobot2BallX / modVectorRobot2Ball;
    vectorRobot2BallY = vectorRobot2BallY / modVectorRobot2Ball;

    long double vectorOriginX = 1;

    long double angleOrigin2ball;
    long double angleRobot2Ball;

    angleOrigin2ball = acos((vectorRobot2BallX * vectorOriginX)); //angulo que a bola faz com o eixo x em relação ao robo

    if(vectorRobot2BallY < 0){ //terceiro e quadrante
        angleOrigin2ball = 2*M_PI - acos((vectorRobot2BallX * vectorOriginX)); //angulo que a bola faz com o eixo x em relação ao robo
    }else{ //primeiro e segundo quadrante
        angleOrigin2ball = acos((vectorRobot2BallX * vectorOriginX)); //angulo que a bola faz com o eixo x em relação ao robo
    }

    long double minValue = 1.5;
    long double maxValue = 2.0;

    long double speed;

    angleRobot2Ball = angleOrigin2Robot - angleOrigin2ball;

    if(fabs(angleRobot2Ball) >= M_PI / 60.0){
        if(abs(angleRobot2Ball) < minValue){
            if(angleRobot2Ball < 0.0) speed = minValue;
            else speed = -minValue;
        }else{
            if(angleRobot2Ball < 0.0){
                if(angleRobot2Ball < -M_PI) speed = -maxValue;
                else speed = maxValue;
            }else{
                if(angleRobot2Ball < M_PI) speed = -maxValue;
                else speed = maxValue;
            }
        }
    }else{
        speed = 0;
    }

    return speed;
}

Velocity getSpeed(double robot_x, double robot_y, double point_x, double point_y, double robotAngle){
    Velocity velocity(true, 0.0, 0.0);
    float Vx = (point_x - robot_x);
    float Vy = (point_y - robot_y);
    float theta = robotAngle;
    float moduloDistancia = sqrt(pow(Vx,2)+pow(Vy,2));
    float vxSaida = (Vx * cos(theta) + Vy * sin(theta))/1000.0;
    float vySaida = (Vx * cos(theta) - Vy * sin(theta))/1000.0;
    float sinalX = 1;
    float sinalY = 1;
    if(vxSaida < 0) sinalX = -1;
    if(vySaida < 0) sinalY = -1;
     if(moduloDistancia > 30.0 ){ 
        vxSaida = std::min(fabs(vxSaida)*0.7, 1.0);
        vySaida = std::min(fabs(vySaida)*0.7, 1.0);
    } else {
        vxSaida = 0;
        vySaida = 0;
    }
    velocity.setVelocityX(fabs(vxSaida) * sinalX);
    velocity.setVelocityY(fabs(vySaida) * sinalY);
    return velocity;
}


Position findBehindBall(float alvoX, float alvoY, float bolaX, float bolaY, float finalDistToPoint){
    Position position(true, 0.0, 0.0);
    float newX = fabs(finalDistToPoint);
    float deltaY=alvoY-bolaY;
    float deltaX=alvoX-bolaX;
    float proporcao = fabs(deltaY/deltaX);
    float newY = proporcao*newX;

    if(bolaX<alvoX) position.setPositionX(bolaX - newX);
    if(bolaX==alvoX) position.setPositionX(bolaX);
    if(bolaX>alvoX) position.setPositionX(bolaX + newX);


    if(bolaY<alvoY) position.setPositionY(bolaY-newY);
    if(bolaY==alvoY) position.setPositionY(bolaY);
    if(bolaY>alvoY) position.setPositionY(bolaY + newY);



    return position;
}