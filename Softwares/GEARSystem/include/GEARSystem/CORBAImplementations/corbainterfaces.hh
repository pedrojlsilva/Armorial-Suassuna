// This file is generated by omniidl (C++ backend)- omniORB_4_2. Do not edit.
#ifndef __corbainterfaces_hh__
#define __corbainterfaces_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif



_CORBA_MODULE GEARSystem

_CORBA_MODULE_BEG

  _CORBA_MODULE CORBATypes

  _CORBA_MODULE_BEG

    struct Angle {
      typedef _CORBA_ConstrType_Fix_Var<Angle> _var_type;

      
      ::CORBA::Boolean isValid;

      ::CORBA::Boolean isUnknown;

      ::CORBA::Float value;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Angle::_var_type Angle_var;

    typedef Angle& Angle_out;

    struct Position {
      typedef _CORBA_ConstrType_Fix_Var<Position> _var_type;

      
      ::CORBA::Boolean isValid;

      ::CORBA::Boolean isUnknown;

      ::CORBA::Float x;

      ::CORBA::Float y;

      ::CORBA::Float z;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Position::_var_type Position_var;

    typedef Position& Position_out;

    struct Velocity {
      typedef _CORBA_ConstrType_Fix_Var<Velocity> _var_type;

      
      ::CORBA::Boolean isValid;

      ::CORBA::Boolean isUnknown;

      ::CORBA::Float x;

      ::CORBA::Float y;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef Velocity::_var_type Velocity_var;

    typedef Velocity& Velocity_out;

    struct AngularSpeed {
      typedef _CORBA_ConstrType_Fix_Var<AngularSpeed> _var_type;

      
      ::CORBA::Boolean isValid;

      ::CORBA::Boolean isUnknown;

      ::CORBA::Float value;

    

      void operator>>= (cdrStream &) const;
      void operator<<= (cdrStream &);
    };

    typedef AngularSpeed::_var_type AngularSpeed_var;

    typedef AngularSpeed& AngularSpeed_out;

  _CORBA_MODULE_END

  _CORBA_MODULE CORBAInterfaces

  _CORBA_MODULE_BEG

#ifndef __GEARSystem_mCORBAInterfaces_mActuator__
#define __GEARSystem_mCORBAInterfaces_mActuator__
    class Actuator;
    class _objref_Actuator;
    class _impl_Actuator;
    
    typedef _objref_Actuator* Actuator_ptr;
    typedef Actuator_ptr ActuatorRef;

    class Actuator_Helper {
    public:
      typedef Actuator_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Actuator, Actuator_Helper> Actuator_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Actuator,Actuator_Helper > Actuator_out;

#endif

    // interface Actuator
    class Actuator {
    public:
      // Declarations for this interface type.
      typedef Actuator_ptr _ptr_type;
      typedef Actuator_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static inline _ptr_type _fromObjRef(omniObjRef* o) {
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Actuator :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      // IDL operations
      void setSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta);
      void kick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power);
      void chipKick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power);
      void kickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power);
      void chipKickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power);
      void holdBall(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable);

      // Constructors
      inline _objref_Actuator()  { _PR_setobj(0); }  // nil
      _objref_Actuator(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Actuator();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Actuator(const _objref_Actuator&);
      _objref_Actuator& operator = (const _objref_Actuator&);
      // not implemented

      friend class Actuator;
    };

    class _pof_Actuator : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Actuator() : _OMNI_NS(proxyObjectFactory)(Actuator::_PD_repoId) {}
      virtual ~_pof_Actuator();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Actuator :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Actuator();

      virtual void setSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta) = 0;
      virtual void kick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power) = 0;
      virtual void chipKick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power) = 0;
      virtual void kickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power) = 0;
      virtual void chipKickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power) = 0;
      virtual void holdBall(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __GEARSystem_mCORBAInterfaces_mController__
#define __GEARSystem_mCORBAInterfaces_mController__
    class Controller;
    class _objref_Controller;
    class _impl_Controller;
    
    typedef _objref_Controller* Controller_ptr;
    typedef Controller_ptr ControllerRef;

    class Controller_Helper {
    public:
      typedef Controller_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Controller, Controller_Helper> Controller_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Controller,Controller_Helper > Controller_out;

#endif

    // interface Controller
    class Controller {
    public:
      // Declarations for this interface type.
      typedef Controller_ptr _ptr_type;
      typedef Controller_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static inline _ptr_type _fromObjRef(omniObjRef* o) {
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Controller :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      // IDL operations
      void teamName(::CORBA::Octet teamNum, ::CORBA::String_out name);
      void teamNumber(const char* name, ::CORBA::Octet& teamNum);
      void teams(::CORBA::String_out teamsStr, ::CORBA::Octet& nTeams, ::CORBA::Boolean& hasTeam0);
      void players(::CORBA::Octet teamNum, ::CORBA::String_out playersStr, ::CORBA::Octet& nPlayers, ::CORBA::Boolean& hasPlayer0);
      void balls(::CORBA::String_out ballsStr, ::CORBA::Octet& nBalls, ::CORBA::Boolean& hasBall0);
      void ballPosition(::CORBA::Octet ballNum, ::GEARSystem::CORBATypes::Position& position);
      void ballVelocity(::CORBA::Octet ballNum, ::GEARSystem::CORBATypes::Velocity& velocity);
      void playerPosition(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Position& position);
      void playerOrientation(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Angle& orientation);
      void playerVelocity(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Velocity& velocity);
      void playerAngularSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::AngularSpeed& angularSpeed);
      void ballPossession(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean& possession);
      void setSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta);
      void kick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power);
      void chipKick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power);
      void kickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power);
      void chipKickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power);
      void holdBall(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable);
      void fieldTopRightCorner(::GEARSystem::CORBATypes::Position& position);
      void fieldTopLeftCorner(::GEARSystem::CORBATypes::Position& position);
      void fieldBottomLeftCorner(::GEARSystem::CORBATypes::Position& position);
      void fieldBottomRightCorner(::GEARSystem::CORBATypes::Position& position);
      void fieldCenter(::GEARSystem::CORBATypes::Position& position);
      void leftGoal(::GEARSystem::CORBATypes::Position& left, ::GEARSystem::CORBATypes::Position& right, ::CORBA::Float& depth, ::CORBA::Float& areaLength, ::CORBA::Float& areaWidth, ::CORBA::Float& areaRoundedRadius);
      void rightGoal(::GEARSystem::CORBATypes::Position& left, ::GEARSystem::CORBATypes::Position& right, ::CORBA::Float& depth, ::CORBA::Float& areaLength, ::CORBA::Float& areaWidth, ::CORBA::Float& areaRoundedRadius);
      void leftPenaltyMark(::GEARSystem::CORBATypes::Position& position);
      void rightPenaltyMark(::GEARSystem::CORBATypes::Position& position);
      void fieldCenterRadius(::CORBA::Float& centerRadius);

      // Constructors
      inline _objref_Controller()  { _PR_setobj(0); }  // nil
      _objref_Controller(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Controller();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Controller(const _objref_Controller&);
      _objref_Controller& operator = (const _objref_Controller&);
      // not implemented

      friend class Controller;
    };

    class _pof_Controller : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Controller() : _OMNI_NS(proxyObjectFactory)(Controller::_PD_repoId) {}
      virtual ~_pof_Controller();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Controller :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Controller();

      virtual void teamName(::CORBA::Octet teamNum, ::CORBA::String_out name) = 0;
      virtual void teamNumber(const char* name, ::CORBA::Octet& teamNum) = 0;
      virtual void teams(::CORBA::String_out teamsStr, ::CORBA::Octet& nTeams, ::CORBA::Boolean& hasTeam0) = 0;
      virtual void players(::CORBA::Octet teamNum, ::CORBA::String_out playersStr, ::CORBA::Octet& nPlayers, ::CORBA::Boolean& hasPlayer0) = 0;
      virtual void balls(::CORBA::String_out ballsStr, ::CORBA::Octet& nBalls, ::CORBA::Boolean& hasBall0) = 0;
      virtual void ballPosition(::CORBA::Octet ballNum, ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void ballVelocity(::CORBA::Octet ballNum, ::GEARSystem::CORBATypes::Velocity& velocity) = 0;
      virtual void playerPosition(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void playerOrientation(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Angle& orientation) = 0;
      virtual void playerVelocity(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::Velocity& velocity) = 0;
      virtual void playerAngularSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::GEARSystem::CORBATypes::AngularSpeed& angularSpeed) = 0;
      virtual void ballPossession(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean& possession) = 0;
      virtual void setSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float x, ::CORBA::Float y, ::CORBA::Float theta) = 0;
      virtual void kick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power) = 0;
      virtual void chipKick(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Float power) = 0;
      virtual void kickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power) = 0;
      virtual void chipKickOnTouch(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable, ::CORBA::Float power) = 0;
      virtual void holdBall(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean enable) = 0;
      virtual void fieldTopRightCorner(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void fieldTopLeftCorner(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void fieldBottomLeftCorner(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void fieldBottomRightCorner(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void fieldCenter(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void leftGoal(::GEARSystem::CORBATypes::Position& left, ::GEARSystem::CORBATypes::Position& right, ::CORBA::Float& depth, ::CORBA::Float& areaLength, ::CORBA::Float& areaWidth, ::CORBA::Float& areaRoundedRadius) = 0;
      virtual void rightGoal(::GEARSystem::CORBATypes::Position& left, ::GEARSystem::CORBATypes::Position& right, ::CORBA::Float& depth, ::CORBA::Float& areaLength, ::CORBA::Float& areaWidth, ::CORBA::Float& areaRoundedRadius) = 0;
      virtual void leftPenaltyMark(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void rightPenaltyMark(::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void fieldCenterRadius(::CORBA::Float& centerRadius) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __GEARSystem_mCORBAInterfaces_mSensor__
#define __GEARSystem_mCORBAInterfaces_mSensor__
    class Sensor;
    class _objref_Sensor;
    class _impl_Sensor;
    
    typedef _objref_Sensor* Sensor_ptr;
    typedef Sensor_ptr SensorRef;

    class Sensor_Helper {
    public:
      typedef Sensor_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_Sensor, Sensor_Helper> Sensor_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_Sensor,Sensor_Helper > Sensor_out;

#endif

    // interface Sensor
    class Sensor {
    public:
      // Declarations for this interface type.
      typedef Sensor_ptr _ptr_type;
      typedef Sensor_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static inline _ptr_type _fromObjRef(omniObjRef* o) {
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_Sensor :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      // IDL operations
      void addTeam(::CORBA::Octet teamNum, const char* teamName);
      void delTeam(::CORBA::Octet teamNum);
      void addBall(::CORBA::Octet ballNum);
      void delBall(::CORBA::Octet ballNum);
      void setBallPosition(::CORBA::Octet ballNum, const ::GEARSystem::CORBATypes::Position& position);
      void setBallVelocity(::CORBA::Octet ballNum, const ::GEARSystem::CORBATypes::Velocity& velocity);
      void addPlayer(::CORBA::Octet teamNum, ::CORBA::Octet playerNum);
      void delPlayer(::CORBA::Octet teamNum, ::CORBA::Octet playerNum);
      void setPlayerPosition(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Position& position);
      void setPlayerOrientation(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Angle& orientation);
      void setPlayerVelocity(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Velocity& velocity);
      void setPlayerAngularSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::AngularSpeed& angularSpeed);
      void setBallPossession(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean possession);
      void setFieldTopRightCorner(const ::GEARSystem::CORBATypes::Position& position);
      void setFieldTopLeftCorner(const ::GEARSystem::CORBATypes::Position& position);
      void setFieldBottomLeftCorner(const ::GEARSystem::CORBATypes::Position& position);
      void setFieldBottomRightCorner(const ::GEARSystem::CORBATypes::Position& position);
      void setFieldCenter(const ::GEARSystem::CORBATypes::Position& position);
      void setLeftGoalPosts(const ::GEARSystem::CORBATypes::Position& left, const ::GEARSystem::CORBATypes::Position& right);
      void setRightGoalPosts(const ::GEARSystem::CORBATypes::Position& left, const ::GEARSystem::CORBATypes::Position& right);
      void setGoalArea(::CORBA::Float length, ::CORBA::Float width, ::CORBA::Float roundedRadius);
      void setGoalDepth(::CORBA::Float depth);
      void setLeftPenaltyMark(const ::GEARSystem::CORBATypes::Position& position);
      void setRightPenaltyMark(const ::GEARSystem::CORBATypes::Position& position);
      void setFieldCenterRadius(::CORBA::Float centerRadius);

      // Constructors
      inline _objref_Sensor()  { _PR_setobj(0); }  // nil
      _objref_Sensor(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_Sensor();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_Sensor(const _objref_Sensor&);
      _objref_Sensor& operator = (const _objref_Sensor&);
      // not implemented

      friend class Sensor;
    };

    class _pof_Sensor : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_Sensor() : _OMNI_NS(proxyObjectFactory)(Sensor::_PD_repoId) {}
      virtual ~_pof_Sensor();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_Sensor :
      public virtual omniServant
    {
    public:
      virtual ~_impl_Sensor();

      virtual void addTeam(::CORBA::Octet teamNum, const char* teamName) = 0;
      virtual void delTeam(::CORBA::Octet teamNum) = 0;
      virtual void addBall(::CORBA::Octet ballNum) = 0;
      virtual void delBall(::CORBA::Octet ballNum) = 0;
      virtual void setBallPosition(::CORBA::Octet ballNum, const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setBallVelocity(::CORBA::Octet ballNum, const ::GEARSystem::CORBATypes::Velocity& velocity) = 0;
      virtual void addPlayer(::CORBA::Octet teamNum, ::CORBA::Octet playerNum) = 0;
      virtual void delPlayer(::CORBA::Octet teamNum, ::CORBA::Octet playerNum) = 0;
      virtual void setPlayerPosition(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setPlayerOrientation(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Angle& orientation) = 0;
      virtual void setPlayerVelocity(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::Velocity& velocity) = 0;
      virtual void setPlayerAngularSpeed(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, const ::GEARSystem::CORBATypes::AngularSpeed& angularSpeed) = 0;
      virtual void setBallPossession(::CORBA::Octet teamNum, ::CORBA::Octet playerNum, ::CORBA::Boolean possession) = 0;
      virtual void setFieldTopRightCorner(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setFieldTopLeftCorner(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setFieldBottomLeftCorner(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setFieldBottomRightCorner(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setFieldCenter(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setLeftGoalPosts(const ::GEARSystem::CORBATypes::Position& left, const ::GEARSystem::CORBATypes::Position& right) = 0;
      virtual void setRightGoalPosts(const ::GEARSystem::CORBATypes::Position& left, const ::GEARSystem::CORBATypes::Position& right) = 0;
      virtual void setGoalArea(::CORBA::Float length, ::CORBA::Float width, ::CORBA::Float roundedRadius) = 0;
      virtual void setGoalDepth(::CORBA::Float depth) = 0;
      virtual void setLeftPenaltyMark(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setRightPenaltyMark(const ::GEARSystem::CORBATypes::Position& position) = 0;
      virtual void setFieldCenterRadius(::CORBA::Float centerRadius) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


#ifndef __GEARSystem_mCORBAInterfaces_mCommandBus__
#define __GEARSystem_mCORBAInterfaces_mCommandBus__
    class CommandBus;
    class _objref_CommandBus;
    class _impl_CommandBus;
    
    typedef _objref_CommandBus* CommandBus_ptr;
    typedef CommandBus_ptr CommandBusRef;

    class CommandBus_Helper {
    public:
      typedef CommandBus_ptr _ptr_type;

      static _ptr_type _nil();
      static _CORBA_Boolean is_nil(_ptr_type);
      static void release(_ptr_type);
      static void duplicate(_ptr_type);
      static void marshalObjRef(_ptr_type, cdrStream&);
      static _ptr_type unmarshalObjRef(cdrStream&);
    };

    typedef _CORBA_ObjRef_Var<_objref_CommandBus, CommandBus_Helper> CommandBus_var;
    typedef _CORBA_ObjRef_OUT_arg<_objref_CommandBus,CommandBus_Helper > CommandBus_out;

#endif

    // interface CommandBus
    class CommandBus {
    public:
      // Declarations for this interface type.
      typedef CommandBus_ptr _ptr_type;
      typedef CommandBus_var _var_type;

      static _ptr_type _duplicate(_ptr_type);
      static _ptr_type _narrow(::CORBA::Object_ptr);
      static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
      
      static _ptr_type _nil();

      static inline void _marshalObjRef(_ptr_type, cdrStream&);

      static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
        omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static inline _ptr_type _fromObjRef(omniObjRef* o) {
        if (o)
          return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
        else
          return _nil();
      }

      static _core_attr const char* _PD_repoId;

      // Other IDL defined within this scope.
      
    };

    class _objref_CommandBus :
      public virtual ::CORBA::Object,
      public virtual omniObjRef
    {
    public:
      // IDL operations
      void addActuator(const char* name, const char* address);
      void delActuator(const char* name);

      // Constructors
      inline _objref_CommandBus()  { _PR_setobj(0); }  // nil
      _objref_CommandBus(omniIOR*, omniIdentity*);

    protected:
      virtual ~_objref_CommandBus();

      
    private:
      virtual void* _ptrToObjRef(const char*);

      _objref_CommandBus(const _objref_CommandBus&);
      _objref_CommandBus& operator = (const _objref_CommandBus&);
      // not implemented

      friend class CommandBus;
    };

    class _pof_CommandBus : public _OMNI_NS(proxyObjectFactory) {
    public:
      inline _pof_CommandBus() : _OMNI_NS(proxyObjectFactory)(CommandBus::_PD_repoId) {}
      virtual ~_pof_CommandBus();

      virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
      virtual _CORBA_Boolean is_a(const char*) const;
    };

    class _impl_CommandBus :
      public virtual omniServant
    {
    public:
      virtual ~_impl_CommandBus();

      virtual void addActuator(const char* name, const char* address) = 0;
      virtual void delActuator(const char* name) = 0;
      
    public:  // Really protected, workaround for xlC
      virtual _CORBA_Boolean _dispatch(omniCallHandle&);

    private:
      virtual void* _ptrToInterface(const char*);
      virtual const char* _mostDerivedRepoId();
      
    };


  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE POA_GEARSystem
_CORBA_MODULE_BEG

  _CORBA_MODULE CORBATypes
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE CORBAInterfaces
  _CORBA_MODULE_BEG

    class Actuator :
      public virtual GEARSystem::CORBAInterfaces::_impl_Actuator,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Actuator();

      inline ::GEARSystem::CORBAInterfaces::Actuator_ptr _this() {
        return (::GEARSystem::CORBAInterfaces::Actuator_ptr) _do_this(::GEARSystem::CORBAInterfaces::Actuator::_PD_repoId);
      }
    };

    class Controller :
      public virtual GEARSystem::CORBAInterfaces::_impl_Controller,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Controller();

      inline ::GEARSystem::CORBAInterfaces::Controller_ptr _this() {
        return (::GEARSystem::CORBAInterfaces::Controller_ptr) _do_this(::GEARSystem::CORBAInterfaces::Controller::_PD_repoId);
      }
    };

    class Sensor :
      public virtual GEARSystem::CORBAInterfaces::_impl_Sensor,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~Sensor();

      inline ::GEARSystem::CORBAInterfaces::Sensor_ptr _this() {
        return (::GEARSystem::CORBAInterfaces::Sensor_ptr) _do_this(::GEARSystem::CORBAInterfaces::Sensor::_PD_repoId);
      }
    };

    class CommandBus :
      public virtual GEARSystem::CORBAInterfaces::_impl_CommandBus,
      public virtual ::PortableServer::ServantBase
    {
    public:
      virtual ~CommandBus();

      inline ::GEARSystem::CORBAInterfaces::CommandBus_ptr _this() {
        return (::GEARSystem::CORBAInterfaces::CommandBus_ptr) _do_this(::GEARSystem::CORBAInterfaces::CommandBus::_PD_repoId);
      }
    };

  _CORBA_MODULE_END

_CORBA_MODULE_END



_CORBA_MODULE OBV_GEARSystem
_CORBA_MODULE_BEG

  _CORBA_MODULE CORBATypes
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

  _CORBA_MODULE CORBAInterfaces
  _CORBA_MODULE_BEG

  _CORBA_MODULE_END

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
GEARSystem::CORBAInterfaces::Actuator::_marshalObjRef(::GEARSystem::CORBAInterfaces::Actuator_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
GEARSystem::CORBAInterfaces::Controller::_marshalObjRef(::GEARSystem::CORBAInterfaces::Controller_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
GEARSystem::CORBAInterfaces::Sensor::_marshalObjRef(::GEARSystem::CORBAInterfaces::Sensor_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}

inline void
GEARSystem::CORBAInterfaces::CommandBus::_marshalObjRef(::GEARSystem::CORBAInterfaces::CommandBus_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}



#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_corbainterfaces
#endif

#endif  // __corbainterfaces_hh__

